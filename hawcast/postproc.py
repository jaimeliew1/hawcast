## -*- coding: utf-8 -*-
"""
Created on 2019-01-07

@author: jyli
"""

import re, os, sys
import numpy as np
import pandas as pd
import click
from .backend import readHawc2Res
from .myDataFrame import myDataFrame
from wetb.fatigue_tools.fatigue import eq_load

def read_csv(filename):
    '''
    Reads a postproc csv file which was generated by the HAWC2Res class. Returns
    a DataFrame
    '''
    df           = myDataFrame(pd.read_csv(filename, header =[0, 1]))
    multicol     = list(df)
    multicol_new = []
    for col in multicol:
        if 'Unnamed' in col[1]:
            multicol_new.append((col[0], ''))
        else:
            multicol_new.append(col)
    df.columns = pd.MultiIndex.from_tuples(multicol_new)
    return df


def isFloat(string):
    try:
        float(string)
        return True
    except ValueError:
        return False


class HAWC2Res(object):
    """A class that processes HAWC2 result files. The result files
       should be contained in a directory and be named by a common string
       pattern"""
    pattern_string = None
    channels       = None

    @property
    def _constructor(self):
       return HAWC2Res

    def __init__(self, directory, pattern_string=None, channels=None):
        # !!!  I dont know how to do the constructor
        self.directory = directory
        pattern_string = pattern_string or self.pattern_string
        pattern, self.fields = self._compile_pattern(pattern_string)

        # get all filenames that fit the pattern
        self.filenames = [x[:-4] for x in os.listdir(directory) if x.endswith('.sel')]
        self.filenames = [x for x in self.filenames if pattern.match(x)]

        self.channels = channels or self.channels
        # Extract input attributes and put in dataframe
        self.dat = []
        for fn in self.filenames:
            self.dat.append([float(x) if isFloat(x) else x for x in pattern.findall(fn)[0]])
        self.dat = myDataFrame(self.dat)

        # set column multi index
        column_tuples = list(zip(*[self.fields, ['']*len(self.fields)]))
        self.dat.columns = pd.MultiIndex.from_tuples(column_tuples,
            names=['channel', 'stat'])

        self.run()


    def run(self):
        # Run in initialisation. To be overwritten when class is inherited
        pass


    def __repr__(self):
        return self.dat.__repr__()

    def __len__(self):
        return(len(self.dat))
        
    @staticmethod
    def _compile_pattern(pattern_string):
        brackets = re.compile('{(.*?)}')
        fields = brackets.findall(pattern_string)
        for field in fields:
            pattern_string = pattern_string.replace('{'+ field +'}', '(.*)')
        return re.compile(pattern_string), fields


    def _add_stat(self, func, stat_name, channels=None):
        '''
        Adds a column of statistics for the given channels using the given function.
        The function should take a pandas series (1d array) and return a float.
        '''
        channel_string = ', '.join(channels)
        print(f'Calculating {stat_name} for {channel_string}...')
        values = []
        if channels is None:
            channels = self.channels
        else:
            channels = {k:v for k,v in self.channels.items() if k in channels}
        N = len(self.filenames)
        with click.progressbar(self.filenames) as bar:
            for fn in bar:
                try:
                    raw = readHawc2Res(os.path.join(self.directory, fn), channels)
                    values.append(func(raw))
                except:
                     print(f'File {fn} could not be loaded.')
                     values.append([np.nan]*len(channels))

        df = pd.DataFrame(values)
        # add multi index columns
        col_ch     = list(channels.keys())
        col_stat   = [stat_name]*len(col_ch)
        col_tuples = list(zip(*[col_ch, col_stat]))
        df.columns = pd.MultiIndex.from_tuples(col_tuples,
                    names=['channel', 'stat'])

        self.dat = self.dat.join(df)
        return self



    def add_mean(self, channels=None):
        func = lambda x: x.mean().values
        return self._add_stat(func, 'Mean', channels)


    def add_var(self, channels=None):
        func = lambda x: x.var().values
        return self._add_stat(func, 'Var', channels)


    def add_std(self, channels=None):
        func = lambda x: x.std().values
        return self._add_stat(func, 'Std', channels)


    def add_final(self, channels=None):
        func = lambda x: x.iloc[-1].values
        return self._add_stat(func, 'final', channels)


    def add_DEL(self, channels, m=4):
        def func(x):
            DEL = []
            for k in channels:
                DEL.append(eq_load(x[k].values, m=m)[0][0])
            return DEL

        return self._add_stat(func, 'DEL', channels)



    def mean_over_row(self, key):
        # used for taking the mean over all seeds
        print(f'Calculating mean over key={key}...')
        in_fields = [x for x in self.fields if x != key]
        out_fields = [x for x in list(self.dat) if x[0] not in self.fields]
        in_atts = self.dat[in_fields].drop_duplicates()
        new_dat = []
        N = len(in_atts)
        with click.progressbar(in_atts.iterrows()) as bar:
            for _, x in bar:
                filt = {k[0]: v for k, v in dict(x).items()}
                new_dat.append(list(x) + list(self.dat(**filt)[out_fields].mean().values))
                
        self.dat = myDataFrame(new_dat)
        # add multi index columns
        col_ch     = in_fields + [x[0] for x in out_fields]
        col_stat   = ['']*len(in_fields) + [x[1] for x in out_fields]
        col_tuples = list(zip(*[col_ch, col_stat]))
        self.dat.columns = pd.MultiIndex.from_tuples(col_tuples,
                    names=['channel', 'stat'])
        return self

    def mean_over_col(self, key_root):
        # used for taking the mean over all blades.
        print(f'Calculating mean over key={key_root}...')
        # get all unique stat indices
        col_stat = list(set(x[1] for x in list(self.dat)))
        for stat in col_stat:
            keys = [x for x in list(self.dat) if key_root in x[0] and x[1] == stat]
            if not keys:
                continue
            self.dat[(key_root, stat)] = self.dat[keys].mean(axis=1)
        return self

    def sort_by(self, key):
        self.dat = self.dat.sort_values(key)
        return self
        
    def sort_columns(self):
        # sorts the columns so that input attributes are first, then output
        # attributes grouped by channel. # TODO
        # use this function to sort by channel in multiindexed columns
        #self.dat.sort_index(axis='columns', level='channel', inplace=True)
        pass

    def to_csv(self, fn):
        print(f'Saving data to {fn}...')
        self.dat.to_csv(fn, index=False)



if __name__ == '__main__':
    pass
